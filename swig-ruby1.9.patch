--- swig/configure.in
+++ swig/configure.in
@@ -1264,6 +1264,10 @@ if test -n "$RUBY"; then
 			fi
 		done
 		if test "$RUBYINCLUDE" = none; then
+			RUBYINCLUDE=`($RUBY -rmkmf -e 'puts "-I#$hdrdir/#{CONFIG["arch"]} -I#$hdrdir/ruby/backward -I#$hdrdir"') 2>/dev/null`
+			AC_MSG_RESULT($RUBYINCLUDE)
+		fi
+		if test "$RUBYINCLUDE" = none; then
 			RUBYINCLUDE="-I$RUBYDIR"
 			AC_MSG_RESULT(could not locate ruby.h...using $RUBYINCLUDE)
 		fi
@@ -1275,7 +1279,7 @@ if test -n "$RUBY"; then
 		rb_bindir=`($RUBY -rrbconfig -e 'print Config::CONFIG[["bindir"]]') 2>/dev/null`
 		dirs="$dirs $rb_libdir $rb_bindir"
 
-        rb_libruby=`($RUBY -rrbconfig -e 'print Config::CONFIG[["LIBRUBY_A"]]') 2>/dev/null`
+        rb_libruby=`($RUBY -rrbconfig -e 'print Config::CONFIG[["LIBRUBY_SO"]]') 2>/dev/null`
         RUBYLINK=`($RUBY -rrbconfig -e '
             c = Config::CONFIG
             if c.has_key? "LIBRUBYARG_STATIC" # 1.8.x
--- rel-1.3.40/Lib/ruby/director.swg	2010-03-02 15:51:00.312186877 +0100
+++ trunk/Lib/ruby/director.swg	2010-03-02 15:26:03.482124438 +0100
@@ -1,7 +1,4 @@
 /* -----------------------------------------------------------------------------
- * See the LICENSE file for information on copyright, usage and redistribution
- * of SWIG, and the README file for authors - http://www.swig.org/release.html.
- *
  * director.swg
  *
  * This file contains support for director classes that proxy
@@ -176,7 +173,7 @@
       try {
 	throw;
       } catch (DirectorException& e) {
-	std::cerr << "Swig Director exception caught:" << std::endl
+	std::cerr << "SWIG Director exception caught:" << std::endl
 		  << e.getMessage() << std::endl;
       } catch (std::exception& e) {
 	std::cerr << "std::exception caught: "<< e.what() << std::endl;
@@ -212,12 +209,12 @@
   class DirectorTypeMismatchException : public Swig::DirectorException {
   public:
     DirectorTypeMismatchException(VALUE error, const char *msg="")
-      : Swig::DirectorException(error, "Swig director type mismatch", msg) 
+      : Swig::DirectorException(error, "SWIG director type mismatch", msg) 
     {
     }
 
     DirectorTypeMismatchException(const char *msg="")
-      : Swig::DirectorException(rb_eTypeError, "Swig director type mismatch", msg) 
+      : Swig::DirectorException(rb_eTypeError, "SWIG director type mismatch", msg) 
     {
     }
 
@@ -238,7 +235,7 @@
     }
 
     DirectorMethodException(const char* msg = "") 
-      : Swig::DirectorException(rb_eRuntimeError, "Swig director method error.", msg) {
+      : Swig::DirectorException(rb_eRuntimeError, "SWIG director method error.", msg) {
     }
     
     static void raise(VALUE error)
@@ -252,7 +249,7 @@
   {
   public:
     DirectorPureVirtualException(const char* msg = "") 
-      : DirectorException(rb_eRuntimeError, "Swig director pure virtual method called", msg)
+      : DirectorException(rb_eRuntimeError, "SWIG director pure virtual method called", msg)
     { 
     }
 
--- rel-1.3.40/Lib/ruby/rubycontainer.swg	2010-03-02 15:51:00.224192289 +0100
+++ trunk/Lib/ruby/rubycontainer.swg	2010-03-02 15:26:03.464124391 +0100
@@ -1,7 +1,4 @@
 /* -----------------------------------------------------------------------------
- * See the LICENSE file for information on copyright, usage and redistribution
- * of SWIG, and the README file for authors - http://www.swig.org/release.html.
- *
  * rubycontainer.swg
  *
  * Ruby sequence <-> C++ container wrapper
@@ -446,11 +443,10 @@
   %typemap(out,noblock=1,fragment="RubySequence_Cont")
     std::pair<const_iterator, const_iterator> {
     $result = rb_ary_new2(2);
-    RARRAY_PTR($result)[0] = SWIG_NewPointerObj(swig::make_const_iterator(%static_cast($1,const $type &).first),
-						swig::ConstIterator::descriptor(),SWIG_POINTER_OWN);
-    RARRAY_PTR($result)[1] = SWIG_NewPointerObj(swig::make_const_iterator(%static_cast($1,const $type &).second),
-						swig::ConstIterator::descriptor(),SWIG_POINTER_OWN);
-    RARRAY_LEN($result) = 2;
+    rb_ary_push($result, SWIG_NewPointerObj(swig::make_const_iterator(%static_cast($1,const $type &).first),
+					    swig::ConstIterator::descriptor(),SWIG_POINTER_OWN));
+    rb_ary_push($result, SWIG_NewPointerObj(swig::make_const_iterator(%static_cast($1,const $type &).second),
+					    swig::ConstIterator::descriptor(),SWIG_POINTER_OWN));
   }
 
   // std::map/multimap/set allow returning std::pair< iterator, iterator > from
@@ -459,11 +455,10 @@
   %typemap(out,noblock=1,fragment="RubySequence_Cont")
     std::pair<iterator, iterator> {
     $result = rb_ary_new2(2);
-    RARRAY_PTR($result)[0] = SWIG_NewPointerObj(swig::make_const_iterator(%static_cast($1,const $type &).first),
-						swig::ConstIterator::descriptor(),SWIG_POINTER_OWN);
-    RARRAY_PTR($result)[1] = SWIG_NewPointerObj(swig::make_const_iterator(%static_cast($1,const $type &).second),
-						swig::ConstIterator::descriptor(),SWIG_POINTER_OWN);
-    RARRAY_LEN($result) = 2;
+    rb_ary_push($result, SWIG_NewPointerObj(swig::make_const_iterator(%static_cast($1,const $type &).first),
+					    swig::ConstIterator::descriptor(),SWIG_POINTER_OWN));
+    rb_ary_push($result, SWIG_NewPointerObj(swig::make_const_iterator(%static_cast($1,const $type &).second),
+					    swig::ConstIterator::descriptor(),SWIG_POINTER_OWN));
   }
 
 
@@ -566,7 +561,8 @@
     {
       Sequence::const_iterator i = $self->begin();
       Sequence::const_iterator e = $self->end();
-      VALUE str = rb_str_new2( swig::type_name< Sequence >() );
+      const char *type_name = swig::type_name< Sequence >();
+      VALUE str = rb_str_new2(type_name);
       str = rb_str_cat2( str, " [" );
       bool comma = false;
       VALUE tmp;
@@ -930,7 +926,7 @@
       } 
       catch( std::invalid_argument )
 	{
-	  rb_raise( rb_eArgError,
+	  rb_raise( rb_eArgError, "%s",
 		    Ruby_Format_TypeError( "", 
 					   swig::type_name<Sequence::value_type>(),
 					   __FUNCTION__, idx+2, elem ));
@@ -957,7 +953,7 @@
 	  }
 	  catch( std::invalid_argument )
 	    {
-	      rb_raise( rb_eArgError,
+	      rb_raise( rb_eArgError, "%s",
 			Ruby_Format_TypeError( "", 
 					       swig::type_name<Sequence::value_type>(),
 					       __FUNCTION__, idx+2, elem ));
@@ -1012,7 +1008,7 @@
 	  if (seq) {
 	    VALUE lastErr = rb_gv_get("$!");
 	    if (lastErr == Qnil) {
-	      rb_raise(rb_eTypeError, e.what());
+	      rb_raise(rb_eTypeError, "%s", e.what());
 	    }
 	  }
 	  return SWIG_ERROR;
@@ -1052,7 +1048,7 @@
 	  if (seq) {
 	    VALUE lastErr = rb_gv_get("$!");
 	    if (lastErr == Qnil) {
-	      rb_raise(rb_eTypeError, e.what());
+	      rb_raise(rb_eTypeError, "%s", e.what());
 	    }
 	  }
 	  return SWIG_ERROR;
@@ -1089,9 +1085,8 @@
 	int i = 0;
 	for (const_iterator it = seq.begin();
 	     it != seq.end(); ++it, ++i) {
-	  RARRAY_PTR(obj)[i] = swig::from< value_type >(*it);
+	  rb_ary_push(obj, swig::from< value_type >(*it));
 	}
-	RARRAY_LEN(obj) = size;
 	rb_obj_freeze(obj);  // treat as immutable result
 	return obj;
       } else {
--- rel-1.3.40/Lib/ruby/rubyhead.swg	2010-03-02 15:51:00.314186593 +0100
+++ trunk/Lib/ruby/rubyhead.swg	2010-03-02 15:26:03.484124144 +0100
@@ -1,5 +1,14 @@
 #include <ruby.h>
 
+/* Ruby 1.9.1 has a "memoisation optimisation" when compiling with GCC which
+ * breaks using rb_intern as an lvalue, as SWIG does.  We work around this
+ * issue for now by disabling this.
+ * https://sourceforge.net/tracker/?func=detail&aid=2859614&group_id=1645&atid=101645
+ */
+#ifdef rb_intern
+# undef rb_intern
+#endif
+
 /* Remove global macros defined in Ruby's win32.h */
 #ifdef write
 # undef write
--- rel-1.3.40/Lib/ruby/rubyrun.swg	2010-03-02 15:51:00.255312167 +0100
+++ trunk/Lib/ruby/rubyrun.swg	2010-03-02 15:26:03.468125042 +0100
@@ -1,7 +1,4 @@
 /* -----------------------------------------------------------------------------
- * See the LICENSE file for information on copyright, usage and redistribution
- * of SWIG, and the README file for authors - http://www.swig.org/release.html.
- *
  * rubyrun.swg
  *
  * This file contains the runtime support for Ruby modules
@@ -45,7 +42,7 @@
 /* Error manipulation */
 
 #define SWIG_ErrorType(code)                            SWIG_Ruby_ErrorType(code)               
-#define SWIG_Error(code, msg)            		rb_raise(SWIG_Ruby_ErrorType(code), msg)
+#define SWIG_Error(code, msg)            		rb_raise(SWIG_Ruby_ErrorType(code), "%s", msg)
 #define SWIG_fail                        		goto fail				 
 
 
@@ -100,7 +97,7 @@
       ++swig_virtual_calls;
 #  define SWIG_RELEASE_STACK --swig_virtual_calls;
 #  define Ruby_DirectorTypeMismatchException(x) \
-          rb_raise( rb_eTypeError, x ); return c_result;
+          rb_raise( rb_eTypeError, "%s", x ); return c_result;
 
       static unsigned int swig_virtual_calls = 0;
 
--- rel-1.3.40/Lib/ruby/std_map.i	2010-03-02 15:51:00.341311583 +0100
+++ trunk/Lib/ruby/std_map.i	2010-03-02 15:26:03.498124411 +0100
@@ -345,7 +345,8 @@
     {
       Map::const_iterator i = $self->begin();
       Map::const_iterator e = $self->end();
-      VALUE str = rb_str_new2( swig::type_name< Map >() );
+      const char *type_name = swig::type_name< Map >();
+      VALUE str = rb_str_new2( type_name );
       str = rb_str_cat2( str, " {" );
       bool comma = false;
       VALUE tmp;
--- rel-1.3.40/Lib/ruby/std_multimap.i	2010-03-02 15:51:00.271311542 +0100
+++ trunk/Lib/ruby/std_multimap.i	2010-03-02 15:26:03.475124457 +0100
@@ -115,7 +115,8 @@
     {
       MultiMap::iterator i = $self->begin();
       MultiMap::iterator e = $self->end();
-      VALUE str = rb_str_new2( swig::type_name< MultiMap >() );
+      const char *type_name = swig::type_name< MultiMap >();
+      VALUE str = rb_str_new2( type_name );
       str = rb_str_cat2( str, " {" );
       VALUE tmp;
       while ( i != e )
--- rel-1.3.40/Lib/ruby/std_pair.i	2010-03-02 15:51:00.272311577 +0100
+++ trunk/Lib/ruby/std_pair.i	2010-03-02 15:26:03.476124367 +0100
@@ -118,13 +118,11 @@
 
       static VALUE from(const std::pair<T,U>& val) {
 	VALUE obj = rb_ary_new2(2);
-	RARRAY_PTR(obj)[0] = swig::from< 
-	  typename swig::noconst_traits<T >::noconst_type>(val.first);
-	RARRAY_PTR(obj)[1] = swig::from(val.second);
-	RARRAY_LEN(obj) = 2;
-	rb_define_singleton_method(obj, "second",  
+	rb_ary_push(obj, swig::from<typename swig::noconst_traits<T >::noconst_type>(val.first));
+	rb_ary_push(obj, swig::from(val.second));
+	rb_define_singleton_method(obj, "second",
 				   VALUEFUNC(_wrap_pair_second), 0 );
-	rb_define_singleton_method(obj, "second=", 
+	rb_define_singleton_method(obj, "second=",
 				   VALUEFUNC(_wrap_pair_second_eq), 1 );
 	rb_obj_freeze(obj); // treat as immutable tuple
 	return obj;
@@ -148,7 +146,8 @@
   VALUE inspect() const
     {
       VALUE tmp;
-      VALUE str = rb_str_new2( swig::type_name< pair >() );
+      const char *type_name = swig::type_name< pair >();
+      VALUE str = rb_str_new2( type_name );
       str = rb_str_cat2( str, " (" );
       tmp = swig::from( $self->first );
       tmp = rb_obj_as_string( tmp );
--- rel-1.3.40/Lib/ruby/std_set.i	2010-03-02 15:51:00.226192283 +0100
+++ trunk/Lib/ruby/std_set.i	2010-03-02 15:26:03.466124065 +0100
@@ -170,10 +170,9 @@
   %typemap(out,noblock=1,fragment="RubyPairBoolOutputIterator")
   std::pair<iterator, bool> {
     $result = rb_ary_new2(2);
-    RARRAY_PTR($result)[0] = SWIG_NewPointerObj(swig::make_set_nonconst_iterator(%static_cast($1,$type &).first),
-						swig::Iterator::descriptor(),SWIG_POINTER_OWN);    
-    RARRAY_PTR($result)[1] = SWIG_From(bool)(%static_cast($1,const $type &).second);
-    RARRAY_LEN($result) = 2;
+    rb_ary_push($result, SWIG_NewPointerObj(swig::make_set_nonconst_iterator(%static_cast($1,$type &).first),
+                                            swig::Iterator::descriptor(),SWIG_POINTER_OWN));
+    rb_ary_push($result, SWIG_From(bool)(%static_cast($1,const $type &).second));
    }
 
   %extend  {
